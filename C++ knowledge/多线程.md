# C++ 11新特性之多线程

## windows

- c++11创建线程

  ```c++
  #include <thread>
  
  void test() {
      // 线程的执行函数
  }
  
  std::thread th(test);
  
  th.join(); // 主线程阻塞等待线程th运行结束
  th.detach(); // 设置线程分离
  
  // 线程传递参数
  void test1(const int& x) {
      cout << &x << endl;
  }
  
  int main() {
      int num = 1;
      int &x = num;
      cout << &x << endl;
      std::thread th(test, x);
  }
  
  // 对于简单基本类型，如int，建议值传递，上述采用引用传递，但是线程中传入的还是拷贝后的副本；
  // 打印可知，地址不同；
  // 如果传递类对象，避免隐式类型转换。全部都要在创建线程就构建临时对象，然后函数参数中用引用，否则系
  // 统还会构造一次
  
  // 获取线程id
  std::this_thread::get_id();
  
  class A {
  public:
      int num;
      A(int _num) : num(_num) {
          cout << "A构造函数执行：" << this << ", thread id = " << std::this_thread::get_id() << endl;
      }
      
      A(const A& a) : num(a.num) {
          cout << "A拷贝构造函数执行：" << this << ", thread id = " << std::this_thread::get_id() << endl;
      }
      
      ~A() {
          cout << "A析构函数执行：" << this << ", thread id = " << std::this_thread::get_id() << endl;
      }
  };
  
  void test(const A& a) {
      cout << "线程test的参数地址：" << &a << ",  thread id = " << std::this_thread::get_id() << endl;
  }
  
  int main() {
      cout << "主线程id：" << std::this_thread::get_id() << endl;
      int num = 2;
      thread th(test, num); // thread th(test, A(num)); 创建临时对象
      th.join();	// 如果改为 th.detach();
      cout << "主线程执行结束" << endl;
      return 0;
  }
  ```

  



## linux