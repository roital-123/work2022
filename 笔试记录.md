[TOC]

# 基础题（选择填空）

##### 编码规则：

- 曼彻斯特编码：[CSDN](https://blog.csdn.net/IT_luosong/article/details/125573506)

  > 低-高：1；
  >
  > 高-低：0；
  
- 差分曼彻斯特：[CSDN](https://www.csdn.net/tags/MtTaEg1sMjI2MDItYmxvZwO0O0OO0O0O.html)

  > 初始信号：曼彻斯特
  >
  > 后续信号，如果信号开始时：
  >
  > 不改变信号极性，表示逻辑1；
  >
  > 改变信号极性，表示逻辑0

- 非归零编码（NRZ：NotReturnZero）：

  > 高电平：1
  >
  > 低电平：0

- 反向不归零编码（NRZI，Non-Return-to-Zero Inverted Code）

  > 信号电平翻转表示：0
  >
  > 信号电平不翻转表示：1

- 4B/5B编码

  > 

##### 排序算法每一趟的结果

- 冒泡：

- 快排

##### 指针求大小

> ```c++
> // 数组已这种形式传参数时，求sizeof得到的结果是指针的大小；
> // 数组定义后，求sizeof是数组大小（参考memset(dp, 0, sizeof(dp))）;
> void test(char c[]) {
>     cout << sizeof(c) << endl;
> }
> ```

##### auto类型推倒

> [zhihu](https://zhuanlan.zhihu.com/p/348520921)
>
> - 普通类型推导
>
>   `auto x = 1; auto y = 1.0;`
>
>   推导为int和double
>
> - 带有&、*的类型推导
>
>   `int x = 1;`
>
>   `const int a = 1;`
>
>   `auto b = a; // int类型`
>
>   `auto &b = a; // const int类型`
>
>   `auto *p1 = &x; // int* 类型 `
>
>   `auto p2 = p1; // int* 类型 `

# 简答题

##### **什么是堆内存？什么是栈内存？**



# 算法题

##### **x，y，a，b；x->y**

```c++
#include <iostream>
using namespace std;

int main()
{
    int x, y, a, b;
    cin >> x >> y >> a >> b;
    if (x > y) swap(x, y);
    
    if (b % a > 0) cout << -1 << endl;
    else {
        int k = b / a;
        int n = 0;
        int l = 0, r = k;
        while (l < r) {
            int mid = (l + 1 + r) / 2;
            if (pow(y, mid) <= k) l=mid;
            else r=mid-1;
        }
        if (pow(y, l) <= k) n = l;
        else n = 0;
        // y最多能用n次
        long long ans = -1;
        for (int i = n; i >= 0; i--) {
            int delt = 0;
            if (i == 0) delt = k;
            else {
                int tmp = pow(y, i);
                if (k % tmp > 0) continue;
                else delt = k / tmp;
            }
            if (delt % x == 0) {
                ans = i + delt / x;
                break;
            }
        }
        cout << ans << endl;
    }

    return 0;
}
```



##### 米哈游：史莱姆种类

```c++
#include <iostream>
#include <queue>
using namespace std;

int a[26];

int main() {
    queue<int> qu;
    int q;
    cin>>q;
    int op;
    char ch;
    
    while(q--) {
        cin>>op;
        if (op == 1) {
            cin>>ch;
            qu.push(ch-'a');
            a[ch-'a']++;
        }
        else if(op == 2) {
            int x = qu.front();
            qu.pop();
            a[x]--;
        }
        else if(op == 3) {
            int type=0;
            for(int i=0; i<26; i++) {
                if (a[i]) { 
                    type++;
                }
            }
            cout << type << endl;
        }
    }
    
    return 0;
}
```



##### 米哈游：蹦蹦史莱姆

```c++
#include <iostream>
#include <queue>
using namespace std;

const int N = 100010;
int dis[N];
int cnt[N];

int main() {
    int n,m;
    cin>>n>>m;
    for(int i=1; i<=n; i++) {
        cin >> dis[i];
    }
    for(int i=1; i<=m; i++) {
        cin >> cnt[i];
    }
    int ans=0;
    for(int i=1; i<=n; i++) {
        if(cnt[dis[i]]) {
            ans += 30;
            cnt[dis[i]]--;
        }
        else {
            break;
        }
    }

    cout << ans << endl;
    
    return 0;
}
```



##### 米哈游：n个节点的树，除叶子结点外，所有节点的相邻节点一定存在两种和它本身不同的颜色（共三种颜色）

> 输入：n（n个节点）
>
> 接下来n-1行：u v（表示u，v之间存在一条无向边相连）
>
> 输出：一种染色的结果
