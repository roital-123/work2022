[TOC]

# 面试题

- [ ] MySQL两种引擎的数据结构？
  - [x] InnoDB
  - [x] MyISAM
- [ ] 事务和锁
  - [x] InnoDB下支持事务，MyISAM不支持

- [x] MVCC（多版本并发控制）底层原理
- [x] MVCC怎么实现的？
- [x] 数据库B+树结构，单个索引的命中过程
- [ ] 联合索引的命中过程
  - [ ] 聚簇索引（主键索引）
  - [ ] 非聚簇索引（其他的索引）

- [x] 多个单索引的命中过程
  - [x] 回表：通过其他索引查询时，其查询结果对应主键索引，需要在回表查一次主键索引
  - [x] 索引下推：
  
- [ ] 数据库删除一个记录时，B+树的变化，效率怎么样
  - [ ] 树结构的平衡调整，影响其他索引对应的树结构，链表指针的调整
- [ ] 说下数据库的ACID。（原子性、一致性、隔离性、持久性）
  - [x] 数据库是怎么实现的ACID的？
  - [x] 数据库事务日志？
- [x] 索引在B+树中的整个命中过程是什么样的？
- [ ] sql语句什么情况下不会用到索引？
  - [ ] 能具体举例吗？
  - [ ] 索引的最左原则，是联合索引中的最左原则
- [ ] B+树的特征，和B树什么区别？
- [ ] 什么时候用B树什么时候用B+树？
- [ ] 大文件中查找某个字符串（提示布隆过滤器和位图来做）？
- [ ] 数据库表锁的应用场景？什么时候会变成表锁？
- [ ] 一个事务如果前三条语句失败了，这时候回滚，回滚时执行undo日志中的语句又失败了，会怎么办？



# 底层数据结构

- B+树

  **原因？**

  > 1、作为一种数据库数据结构，必须是一种K-V格式
  >
  > 2、支持K-V格式的有：哈希表，树
  >
  > 3、为什么不选择哈希表呢？
  >
  > - 哈希表不支持范围查找；
  > - 哈希冲突；
  > - 哈希函数不合理会导致查询效率退化（可以展开分析哈希表底层原理？）
  >
  > 4、选择什么树形结构呢？
  >
  > - 二叉树 ----> BST 可能不平衡
  > - 平衡二叉树或红黑树：相对平衡，但是数据量很大时，树高增高带来了查询效率变慢
  > - B树：每个节点存储数据导致，B树的每个节点存储的关键字个数不够多
  > - B+树：只在叶子节点存储具体数据，其他节点存储索引；因此，查询时候，从磁盘中加载一页到内存能够查询的关键字个数显著提高。
  > - B+树一般三阶或四阶足够满足千万级别的数据量了；如果数据量再大一些，就涉及到分库分表了。



# MyISAM与InnoDB

> InnoDB支持事务；MyISAM不支持；
>
> **InnoDB对每一条SQL语言都默认封装成事务，自动提交**；影响效率，因此，业务中最好把多条SQL放在**begin**和**commit**之间，组成一个事务，集中提交；
>
> - InnoDB是**聚集索引**：表数据和索引存在一个文件中：如：**table.ibd** 中就存放了索引和数据；
>
> - MyISAM是**非聚集索引**：表数据和索引分别存放；如 **table.MYD** 中存放的就是表数据；**table.MYI** 中存放的就是表的索引；
>
> MyISAM执行查询SQL时会判断查询条件是否有索引，如果有则会去MYI中定位索引元素，找到**索引对应的数据的地址**，再根据地址去MYD文件获取对应的数据；
>
> InnoDB在执行查询时，如果有**主键**，则根据**主键索引**在存储结构中查询到**叶子节点**；B+树的叶子节点存储了所有的索引和他对应的数据；
>
> 如果是**非主键索引**，其查询的叶子节点上，key是非主键索引，value是主键索引的地址；再通过**主键索引**的地址找到主键索引节点下的数据；
>
> B+树下一个表如果不建**主键**，Mysql会查找一个所有元素都不重复的列字段作为主键索引，如果没有，则会自动创建了隐藏的**自增列**作为主键；这一步影响性能；
>
> **主键**：最好是整型自增；
>
> - 整型：B+树的索引结构是按顺序排序的，整型比大小比非整型要快；
> - 自增：避免树结构**频繁**分裂。因为使用自增，构建**索引树**的时候加入的数据都是从后面插入到索引树中；非自增插入索引时，因为要遵循顺序，所以可能会插入到之前，带来树结构的分裂，也影响性能；



# MVCC—多版本并发控制

[参考](https://blog.csdn.net/SnailMann/article/details/94724197)

> **MVCC**在**InnoDB**中的实现主要是为了提高数据库的并发性能，用更好的方式去处理**读-写冲突**，做到即使有**读写-冲突**时，也能做到不加锁，非阻塞并发读；
>
> - **当前读**：
>
>   读取的是**记录的最新版本**，读取时还要保证其他**并发事务**不能修改当前记录，会对读取的记录进行加锁；
>
> - **快照读**：
>
>   像普通的**不加锁**的 `SELECT` 操作就是快照读，即不加锁的非阻塞读；在**串形化**的隔离级别下快照读会退化为当前读；
>
>   快照读是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制；在很多情况下，避免了加锁操作，降低了开销；快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本；



> - **DB_TRX_ID**：记录操作创建这条记录/（最后一次修改该记录）的事务ID（版本号）
> - **DB_ROLL_PTR**：回滚指针，指向这条记录的上一个版本
> - **DB_ROW_ID**：隐藏ID，当表没有合适索引作为聚集索引时，会用该隐藏ID创建聚集索引



> **undo log**：insert undo log 和 update undo log两种
>
> 保证事务进行**rollback**时的原子性和一致性，当事务进行回滚的时候可以用undo log里的数据进行恢复；
>
> 用于**MVCC**快照读的数据，在MVCC中，通过读取undo log的历史数据可以实现不同事务版本号都拥有自己独立的快照数据版本；
>
> **undo log在插入数据时的使用过程**
>
> - 开启一个事务，获取一个事务版本号 x
> - 把表修改前的数据拷贝到undo log中
> - 修改表的数据，并将修改后的事务版本号改为x，并将**DB_ROLL_PTR**地址指向undo log中刚拷贝数据的位置



> **Read view**：
>
> InnoDB中每个事务开启后都会得到一个read view。其中保存了几个重要的熟悉：
>
> - **trx_ids**：当前系统未提交的事务版本号集合（包括自己）：**uncommit_list**
> - **low_limit_id**：当前系统**最大事务版本号+1**：**next num**
> - **up_limit_id**：当前系统中**未提交的最小事务版本号** ：**min_uncommit**
> - **creator_trx_id**：创建当前read view的事务版本号：**self**
>
> 根据当前**数据事务ID**和其创建的read view觉得显示的数据版本：
>
> - **cur** < **min_uncommit**
>
>   当前数据在开始当前事务前被之前开启的事务提交了，正常显示；
>
> - **cur** >= **next num**
>
>   当前数据是开始当前事务后，又开启的另一个事务提交的，不应该显示；
>
> - **min_uncommit** <= **cur**  < **next num**
>
>   cur == self，自己的数据正常显示；
>
>   cur != self，不显示
>
> - 对于**不满足read view显示条件**的数据，从undo log中获取数据，找到版本号低于cur的第一个记录；



> **insert undo log 和 updata undo log** 中链表节点的记录何时删除？更新和删除操作只是设置了老的记录的**delete_bit**，并不是真正将过时的记录删除；
>
> **purge线程：**专门来清理delete bit为true的记录；purge线程自己也维护了一个**read view**；相当于系统中最老的活跃事务的read view，如果某条记录的**DB_TRX_ID**事务ID对purge的read_view可见，那么他一定是可以被安全删除的。
>
> 
>
> **insert undo log** 是指在insert操作中产生的undo log，因为insert操作记录，只对事务本身可见，对其他事务不可见，所以undo log可以在事务提交后直接删除。
>
> insert操作产生的insert undo log节点中回滚指针为**null**，在事务回滚时，就可以知道当前的记录只要删除就可以保证事务的一致性了。



> **RC RR级别下的InnoDB快照读区别**：
>
> RR：可重复读：某个事务对某一条记录的**第一次**快照读会创建一个快照和Read View，将当前系统活跃的其他事务记录下来，此后再调用快照读的时候，使用的都是同一个Read View；
>
> RC ：读提交：在事务中每次快照都会新生成一个快照和Read View；因此**在RC级别下的事务中**可以看到别的事务提交的更新；































