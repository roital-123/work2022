[TOC]

# 面试题

- [x] MySQL两种引擎的数据结构？
  - [x] InnoDB
  - [x] MyISAM
- [x] 事务和锁
  - [x] InnoDB下支持事务，MyISAM不支持

- [x] MVCC（多版本并发控制）底层原理
- [x] MVCC怎么实现的？
- [x] 数据库B+树结构，单个索引的命中过程
- [x] 联合索引的命中过程
  - [x] 聚簇索引（主键索引）
  - [x] 非聚簇索引（其他的索引）

- [x] 多个单索引的命中过程
  - [x] 回表：通过其他索引查询时，其查询结果对应主键索引，需要在回表查一次主键索引
  - [x] 索引下推：
  
- [ ] 数据库删除一个记录时，B+树的变化，效率怎么样
  - [ ] 树结构的平衡调整，影响其他索引对应的树结构，链表指针的调整
- [x] 说下数据库的ACID。（原子性、一致性、隔离性、持久性）
  - [x] 数据库是怎么实现的ACID的？
  - [x] 数据库事务日志？
- [x] 索引在B+树中的整个命中过程是什么样的？
- [x] sql语句什么情况下不会用到索引？
  - [x] 能具体举例吗？
  - [x] 索引的最左原则，是联合索引中的最左原则
- [x] B+树的特征，和B树什么区别？
- [x] 什么时候用B树什么时候用B+树？
- [ ] 大文件中查找某个字符串（提示布隆过滤器和位图来做）？
- [x] 数据库表锁的应用场景？什么时候会变成表锁？
- [ ] 一个事务如果前三条语句失败了，这时候回滚，回滚时执行undo日志中的语句又失败了，会怎么办？



# 底层数据结构

- B+树

  **原因？**

  > 1、作为一种数据库数据结构，必须是一种K-V格式
  >
  > 2、支持K-V格式的有：哈希表，树
  >
  > 3、为什么不选择哈希表呢？
  >
  > - 哈希表不支持范围查找；
  > - 哈希冲突；
  > - 哈希函数不合理会导致查询效率退化（可以展开分析哈希表底层原理？）
  >
  > 4、选择什么树形结构呢？
  >
  > - 二叉树 ----> BST 可能不平衡
  > - 平衡二叉树或红黑树：相对平衡，但是数据量很大时，树高增高带来了查询效率变慢
  > - B树：每个节点存储数据导致，B树的每个节点存储的关键字个数不够多
  > - B+树：只在叶子节点存储具体数据，其他节点存储索引；因此，查询时候，从磁盘中加载一页到内存能够查询的关键字个数显著提高。
  > - B+树一般三阶或四阶足够满足千万级别的数据量了；如果数据量再大一些，就涉及到分库分表了。



# MyISAM与InnoDB

> InnoDB支持事务；MyISAM不支持；
>
> **InnoDB对每一条SQL语言都默认封装成事务，自动提交**；影响效率，因此，业务中最好把多条SQL放在**begin**和**commit**之间，组成一个事务，集中提交；
>
> - InnoDB是**聚集索引**：表数据和索引存在一个文件中：如：**table.ibd** 中就存放了索引和数据；
>
> - MyISAM是**非聚集索引**：表数据和索引分别存放；如 **table.MYD** 中存放的就是表数据；**table.MYI** 中存放的就是表的索引；
>
> MyISAM执行查询SQL时会判断查询条件是否有索引，如果有则会去MYI中定位索引元素，找到**索引对应的数据的地址**，再根据地址去MYD文件获取对应的数据；
>
> InnoDB在执行查询时，如果有**主键**，则根据**主键索引**在存储结构中查询到**叶子节点**；B+树的叶子节点存储了所有的索引和他对应的数据；
>
> 如果是**非主键索引**，其查询的叶子节点上，key是非主键索引，value是主键索引的地址；再通过**主键索引**的地址找到主键索引节点下的数据；
>
> B+树下一个表如果不建**主键**，Mysql会查找一个所有元素都不重复的列字段作为主键索引，如果没有，则会自动创建了隐藏的**自增列**作为主键；这一步影响性能；
>
> **主键**：最好是整型自增；
>
> - 整型：B+树的索引结构是按顺序排序的，整型比大小比非整型要快；
> - 自增：避免树结构**频繁**分裂。因为使用自增，构建**索引树**的时候加入的数据都是从后面插入到索引树中；非自增插入索引时，因为要遵循顺序，所以可能会插入到之前，带来树结构的分裂，也影响性能；



# MVCC—多版本并发控制

[参考](https://blog.csdn.net/SnailMann/article/details/94724197)

> **MVCC**在**InnoDB**中的实现主要是为了提高数据库的并发性能，用更好的方式去处理**读-写冲突**，做到即使有**读写-冲突**时，也能做到不加锁，非阻塞并发读；
>
> - **当前读**：
>
>   读取的是**记录的最新版本**，读取时还要保证其他**并发事务**不能修改当前记录，会对读取的记录进行加锁；
>
> - **快照读**：
>
>   像普通的**不加锁**的 `SELECT` 操作就是快照读，即不加锁的非阻塞读；在**串形化**的隔离级别下快照读会退化为当前读；
>
>   快照读是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制；在很多情况下，避免了加锁操作，降低了开销；快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本；



> - **DB_TRX_ID**：记录操作创建这条记录/（最后一次修改该记录）的事务ID（版本号）
> - **DB_ROLL_PTR**：回滚指针，指向这条记录的上一个版本
> - **DB_ROW_ID**：隐藏ID，当表没有合适索引作为聚集索引时，会用该隐藏ID创建聚集索引



> **undo log**：insert undo log 和 update undo log两种
>
> 保证事务进行**rollback**时的原子性和一致性，当事务进行回滚的时候可以用undo log里的数据进行恢复；
>
> 用于**MVCC**快照读的数据，在MVCC中，通过读取undo log的历史数据可以实现不同事务版本号都拥有自己独立的快照数据版本；
>
> **undo log在插入数据时的使用过程**
>
> - 开启一个事务，获取一个事务版本号 x
> - 把表修改前的数据拷贝到undo log中
> - 修改表的数据，并将修改后的事务版本号改为x，并将**DB_ROLL_PTR**地址指向undo log中刚拷贝数据的位置



> **Read view**：
>
> InnoDB中每个事务开启后都会得到一个read view。其中保存了几个重要的熟悉：
>
> - **trx_ids**：当前系统未提交的事务版本号集合（包括自己）：**uncommit_list**
> - **low_limit_id**：当前系统**最大事务版本号+1**：**next num**
> - **up_limit_id**：当前系统中**未提交的最小事务版本号** ：**min_uncommit**
> - **creator_trx_id**：创建当前read view的事务版本号：**self**
>
> 根据当前**数据事务ID**和其创建的read view觉得显示的数据版本：
>
> - **cur** < **min_uncommit**
>
>   当前数据在开始当前事务前被之前开启的事务提交了，正常显示；
>
> - **cur** >= **next num**
>
>   当前数据是开始当前事务后，又开启的另一个事务提交的，不应该显示；
>
> - **min_uncommit** <= **cur**  < **next num**
>
>   cur == self，自己的数据正常显示；
>
>   cur != self，不显示
>
> - 对于**不满足read view显示条件**的数据，从undo log中获取数据，找到版本号低于cur的第一个记录；



> **insert undo log 和 updata undo log** 中链表节点的记录何时删除？更新和删除操作只是设置了旧的记录的**delete_bit**，并不是真正将过时的记录删除；
>
> **purge线程：**专门来清理delete bit为true的记录；purge线程自己也维护了一个**read view**；相当于系统中最久远的活跃事务的read view，如果某条记录的**DB_TRX_ID**事务ID对purge的read_view可见，那么他一定是可以被安全删除的。
>
> 
>
> **insert undo log** 是指在insert操作中产生的undo log，因为insert操作记录，只对事务本身可见，对其他事务不可见，所以undo log可以在事务提交后直接删除。
>
> insert操作产生的insert undo log节点中回滚指针为**null**，在事务回滚时，就可以知道当前的记录只要删除就可以保证事务的一致性了。



> **RC RR级别下的InnoDB快照读区别**：
>
> RR：可重复读：某个事务对某一条记录的**第一次**快照读会创建一个快照和Read View，将当前系统活跃的其他事务记录下来，此后再调用快照读的时候，使用的都是同一个Read View；
>
> RC ：读提交：在事务中每次快照都会新生成一个快照和Read View；因此**在RC级别下的事务中**可以看到别的事务提交的更新；



# 索引

- 聚簇索引：主键索引

- 非聚簇索引：其他的索引

  > 两者的区别就是聚簇索引的叶子结点存储了查询结果的所有信息；
  >
  > 非聚簇索引的叶子结点存储的只是查询结果对应的主键索引信息，要想查询所有的信息，还需要根据第一步查询到的主键索引信息进行一次**回表**操作，才能得到查询记录的所有信息；

- 索引类型：

  - 主键索引

    > 要求：与表中其他列不相关，与业务也不相关；不允许为null
    >
    > 一般是 `int` 类型且自增：
    >
    > 原因：
    >
    > 主键索引不需要手动创建，在创建表时**MYSQL**会自动添加一个与主键对应的索引：
    >
    > 分析：如果没有设置主键，则**MYSQL**会先判断表中是否存在非空且唯一的字段，如果有，根据其设为主键；如果没有，则**MYSQL**会自动创建一个隐藏的自增列作为主键索引（消耗性能）；

  - 唯一索引

    > 与主键索引区别就是，支持值为null

  - 普通索引

    > 最基本的索引：
    >
    > `CREATE INDEX IDX_XXX ON STUDENT(NAME);`
    >
    > `ALTER TABLES STUDENT ADD INDEX IDX_XXX(NAME);`

  - 组合索引（联合索引）

    > 可以为多个字段创建联合索引，如为**col1, col2, col3**三个字段建立索引，查询（col1），（col1，col2），（col1，col2，col3）可以使用该索引；
    >
    > 组合索引的在**InnoDB**下的底层结构也是B+树，只不过在比较时按照索引中字段的顺序比较；
    >
    > [联合索引的B+树存储结构](https://juejin.cn/post/6844904073955639304)

  - 全文索引

    > 大数据量下做模糊匹配比**LIKE%**效率高
    >
    > `CREATE FULLTEXT INDEX IDX_XXX ON STUDENT(INTRODUCE);`
    >
    > `SELECT * FROM STUDENT WHERE MATCH(INTRODUCE) AGAINST ('SPORTS');`
    >
    > 具有独特的语法结构**MATCH**和**AGAINST**，其中**MATCH**和**AGAINST**括号后的的字段名和字段值都必须和创建全文索引时的字段名完全匹配，不可多不可少。

- 索引覆盖（覆盖索引）

  > 覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。
  >
  > 通过联合索引的形式：
  >
  > 如：一个学生表中，为学生名称和学生学院建立联合索引；
  >
  > 在执行根据名称查询学院的sql查询时，就可以在第一次索引查询中直接返回其学院的信息

- 什么场景下不会用到索引？

  [索引失效场景](https://juejin.cn/post/7069562982711164965)

  EXPLAIN 查看：如：

  `explain select * from t_user where id not in (2,3);`

  > - **单个索引**：
  >
  >   使用不等于符号 `!=` `<>` 导致索引失效
  >
  > - **类型不一致导致的索引失效**
  >
  >   表字段类型设计时的类型和使用时的类型如果不一致，可能会有隐式的类型转换；
  >
  > - **函数导致索引失效**
  >
  >   `SELECT * FROM STUDENT WHERE SUBSTR(ID_NO, 1, 3) = '100';`
  >
  > - **运算符导致索引失效**
  >
  >   假设**AGE**列是索引列
  >
  >   `SELECT * FROM STUDENT WHERE AGE-1 = 20;` 不走索引
  >
  >   `SELECT * FROM STUDENT WHERE AGE = 20-1;` 走索引
  >
  > - **OR引起的索引失效**
  >
  >   **OR**导致索引失效是在特殊的情况下，并不是所有的**OR**都会是索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效
  >
  >   `SELECT * FROM STUDENT WHERE NAME = 'ANDY' OR NAME = 'JACK';` 走索引
  >
  >   `SELECT * FROM STUDENT WHERE NAME = 'ANDY' OR AGE = 25;` 不走索引
  >
  > - **模糊搜索导致的索引失效**
  >
  >   `SELECT * FROM STUDENT WHERE NAME LIKE '张%'；` 
  >
  >   后置的通配符（后匹配），从前面去匹配索引列
  >
  >   `SELECT * FROM STUDENT WHERE NAME LIKE '%明'；` 
  >
  >   `SELECT * FROM STUDENT WHERE NAME LIKE '%子%'；` 
  >
  >   前置的通配符（前匹配），无法走索引
  >
  > - **NOT IN、NOT EXISTS**导致索引失效，索引不能存储**NULL**值
  >
  >   解决方法就是给默认值
  >
  > - **联合索引未遵循最左前缀匹配原则**
  >
  > - **两列做比较，即使两列都建索引**
  >
  >   `SELECT * FROM STUDENT WHERE MATHMARK = ENGLISHMARK;` 数学成绩和英语成绩一样
  >
  > - **ORDER BY导致索引失效**
  >
  >   情况较多？可能走，可能不走。
  >
  >   [参考](https://cloud.tencent.com/developer/article/1666887)

- **索引下推**

  > [参考](https://juejin.cn/post/6844904017332535304)
  >
  > **仔细理解链接中的两种方式❗️**
  >
  > 索引条件下推优化（Index Condition Pushdown (ICP) ）是**MySQL5.6**添加的，用于优化数据查询。 
  >
  > - 不使用索引条件下推优化时**存储引擎**通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件。 
  > - 当使用索引条件下推优化时，如果**存在某些被索引的列的判断条件时**，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。
  >
  > 例如：
  >
  > 其中索引为（name address）
  >
  > `SELECT * FROM PERSON WHERE NAME = '1' AND ADDRESS LIKE '%222';`
  >
  > 如果不使用索引条件下推优化的话，MySQL只能根据索引查询出**name=1**的所有行，然后再依次比较是否符合全部条件；
  >
  > 当使用了索引条件下推优化技术后，可以 **判断当前索引对应的数据**是否符合条件，只有符合条件的数据才将整行数据查询出来；



# 数据库锁

[参考](https://blog.csdn.net/C_J33/article/details/79487941)

**通常讨论的数据库锁机制都是悲观锁**

> MyISAM中只使用了表锁，不会有死锁的问题；锁开销小，但是并发能力差；
>
> InnoDB实现了行级锁和表锁，锁的粒度变小，并发能力也变强了，但是相应的锁的开销变大了；
>
> InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才会使用行级锁，否则使用将表锁。

- 表锁：

- 行锁：

  > `SELECT * FROM STUDENT;`
  >
  > 默认情况下，数据库会首先锁定第一行，读取后，解除对第一行的锁定；然后是第二行。。。这样，在一个事务读操作的过程中，允许其他事务同时更新**STUDENT**表中未锁定的行（注意MVCC在其中起到的作用）；

- 意向锁：解决事务在申请表锁时，需要逐行判断行锁的情况；

  > 判断表是否已被其他事务用表锁锁表
  >
  > （old：判断表中每一行是否已被行锁锁住）
  >
  > 发现表上有意向共享锁，说明表中有些行被共享行锁锁住，因此事务在申请表的写锁时会被阻塞；
  >
  > 申请意向锁的动作是数据库完成的，即事务A申请一行的行锁时，数据库会自动先开始申请表的意向锁；

- 独占锁

  > 加锁与解锁：当一个事务执行**insert**、**update**或**delete**语句时，数据库系统会自动对SQL语句操纵的数据资源使用独占锁。
  >
  > 如果该数据资源已经有其他锁（任何锁）存在时，就无法对其再放置独占锁了。

- 更新锁

  > 更新锁在的初始化阶段用来锁定可能要被修改的资源，这可以避免使用共享锁造成的死锁现象；
  >
  > 更新操作需要分两步：读取表中记录 –> 执行更新操作；
  >
  > 如果第一步使用**共享锁**，`SELECT`读取数据；
  >
  > 第二步在将锁升级为**独占锁**，就会出现死锁现象；
  >
  > 解决方法：
  >
  > 当一个事务执行**UPDATE**语句时，数据库系统会先为事务分配一把**更新锁**。当读取数据完毕，执行更新操作时，会把更新锁升级为**独占锁**；
  >
  > **更新锁和共享锁时兼容的**，一个资源可以同时放置更新锁和共享锁，但是最多放置一把更新锁。当多个事务更新相同数据时，只有一个事务获得更新锁，然后再把更新锁升级为独占锁，其他事务必须等到前一个事务结束后，才能获取更新锁，即避免了死锁；



# B树的场景B+树的场景

- **MYSQL关系型数据库**

  > B+树结构

- **MongoDB非关系型数据库**

  > 其索引结构使用的是B树结构



















