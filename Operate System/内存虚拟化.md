# 分析—内存虚拟化：

> 1、高效和控制
>
> - 高效：程序大部分指令直接访问硬件——（需要硬件支持：**寄存器**，**TLB**）
> - 控制：在程序运行的**关键点及时介入**来保证对硬件的控制
>
> 2、进程需要加载到物理内存——基于硬件的地址转换（动态重定位）：**基址**寄存器，**界限**寄存器
>
> - **MMU**：内存管理单元：将CPU的负责地址转换的部分统称为MMU
> - 进程中使用的内存引用都是**虚拟地址**



#### 由于将进程的地址空间完整的加载到物理内存，会产生浪费，比如：堆栈区中间有“空闲区间”：



# 引入：段表

- 想法：在MMU中引入不止一个基址、界限寄存器，每个段一对；

- 当对虚拟地址空间分段加载到内存中

  > 粗略的将虚拟地址空间分为：代码段、堆段、栈段；
  >
  > 其中，代码段和堆段前几位充当段号，后续充当段内偏移；
  >
  > 其中栈由于是从高地址向低地址扩充的，因此，其偏移的计算稍微不同；
  >
  > 需要将偏移减去段支持的最大偏移空间大小：如11 0000 0000 0000 ～ 11 1111 1111 1111
  >
  > 这里的偏移空间有4KB的大小，因此计算实际偏移需要减去4KB
  
- 问题：分段会带来**外部碎片**的问题；



#### 看看为了避免外部碎片使用的方式？：



# 引入：页表

- 基本想法：将物理内存分成大小固定的一页一页（称为**页帧**）

- 进程的**虚拟地址空间**中的每一页都映射到物理内存上——**页表**（记录这种映射关系）

- 每个进程都有一份页表；

- 页表中的信息

  > 它的数据结构就是：虚拟页号（VPN-virtual page number）——>物理帧号（PFN-physical frame number）/或者物理页号（PPN-physical page number）
  >
  > 页表中的每一项为页表项 PTE （page table entries）：
  >
  > ​	有效位：在稀疏地址空间中很有效：将堆栈中空闲区域有效位置0，则不需要分配物理内存
  >
  > ​	保护位：当前页读、写、执行权限
  >
  > ​	存在位：该页在物理存储器还是在磁盘（换入换出）
  >
  > ​	脏位：是否被修改
  >
  > ​	访问位：是否被访问，在页面替换中使用（标志当前页是否活跃）

- 问题：

  > 访问页表：带来额外的内存引用，耗时
  >
  > 页表占据内存空间：内存浪费



#### 如何解决访问页表的耗时问题？



# 引入：TLB——地址转换旁路缓冲存储器

- 根据VPN先去查看TLB，找到则命中；

- 若TLB中没有，转为普通的查询，将新的映射关系加入TLB中。再根据VPN找PFN，此时一定命中；

- 如果未命中：

  > CISC：（复杂指令集计算机）硬件负责；因此，硬件需要知道页表在内存中位置，硬件在页表中找到对应的映射；
  >
  > RISC：（精简指令集计算机）软件负责；**硬件抛出异常**，转入**陷进处理程序**；这段程序会查找页表中的映射，在用**特权指令**更新TLB；**然后，硬件会重试该指令，这是将会命中**；
  >
  > 注意：
  >
  > 1、硬件必须从导致陷阱的指令继续执行（而不是下一条指令）
  >
  > 2、避免无限TLB未命中。
  >
  > ​	陷进处理程序直接放在物理内存中，没有被映射过；
  >
  > ​	TLB中永久保留一些位置留给这个处理程序的映射；



#### 如何解决大量页表占据物理内存？



# 引入1：分段+分页

> 如果页表大了，那就把页变大，页表则变小了，不是吗？
>
> 带来新的问题：大内存页会导致页内浪费，产生**内部碎片**，不合理；
>
> 分段+分页：
>
> MMU中每个段的**基址寄存器**：页表的物理地址
>
> **界限寄存器**：页表结尾，即有多少个有效页
>
> 还是有问题：无法解决大而稀疏的堆，而且又带来外部碎片



# 引入2：多级页表

> 多级页表：线性页表——>多级页表
>
> 思想：将页表分成页大小单元，如果**整页的PTE无效**，就不分配该页的页表；为了追踪页表的页是否有效，（以及如果有效，其物理地址），使用页目录的新结构。
>
> 多级页表分配的页表空间，与正在使用的地址空间内存量成正比，而且**支持稀疏地址空间**。
>
> 新问题：如果TLB未命中，需要额外访问内存（具体次数取决于页表层级）